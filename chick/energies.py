from chick.utils.plot_utils import plot_2D
from chick.utils.types import Energy
from chick.projection import Projection

from torch.distributions import Normal

proj = Projection.from_pretrained()

def gaussian_2d_energy(x_sample, x_2d, x_2d_std, center, camera, **kwargs) -> Energy:
    """
        Energy function for conditioning on a monocular 2D pose using a gaussian approximation. of the distribution.
        :param x_sample: The 3D pose sample generated by the model.
        :param x_2d: The 2D pose.
        :param center: The center of the 3D pose.
        :param camera: The camera used to project the 3D pose.
        :return: The energy of the sample.
        """
    x_sample = x_sample - center.unsqueeze(0).permute(0, 1, 3, 2)
    x_sample = x_sample.permute(0, 3, 1, 2)
    x_2d_projected = camera.proj2D(x_sample)

    _x_2d = x_2d.permute(0, 3, 1, 2).clone()

    dist = Normal(_x_2d, x_2d_std)

    energy = -dist.log_prob(x_2d_projected).mean(-1).mean(-1).sum(-1)

    return {
        "train": energy,
    }

def monocular_2d_energy(x_sample, x_2d, center, camera, **kwargs) -> Energy:
    """
    Energy function for conditioning on a monocular 2D pose.
    :param x_sample: The 3D pose sample generated by the model.
    :param x_2d: The 2D pose.
    :param center: The center of the 3D pose.
    :param camera: The camera used to project the 3D pose.
    :return: The energy of the sample.
    """
    x_sample = x_sample - center.unsqueeze(0).permute(0, 1, 3, 2)
    x_sample = x_sample.permute(0, 3, 1, 2)
    x_2d_projected = camera.proj2D(x_sample)

    _x_2d = x_2d.permute(0, 3, 1, 2).clone()

    energy = (
        ((x_2d_projected - _x_2d) ** 2).mean(-1).mean(-1).sum(-1)
    )

    return {
        "train": energy,
    }

def learned_2d_energy(x_sample, x_2d, center, camera, **kwargs) -> Energy:
    """
    Energy function for conditioning on a monocular 2D pose.
    :param x_sample: The 3D pose sample generated by the model.
    :param x_2d: The 2D pose.
    :param center: The center of the 3D pose.
    :param camera: The camera used to project the 3D pose.
    :return: The energy of the sample.
    """
    x_sample = x_sample# - center.unsqueeze(0).permute(0, 1, 3, 2)
    x_sample = x_sample.permute(0, 3, 1, 2)
    x_2d_projected = proj(x_sample)

    # print(x_2d.shape)
    x_2d = x_2d - x_2d[:, 0:1, :, :]
    _x_2d = x_2d.permute(0, 3, 1, 2).clone()

    energy = (
        ((x_2d_projected - _x_2d) ** 2).mean(-1).mean(-1).sum(-1)
    )

    # print(energy)

    return {
        "train": energy,
    }

def inpaint_2d_energy(x_sample, x_2d, center, **kwargs):
    return {
        "input_2D": x_2d + center.unsqueeze(0).permute(0, 1, 3, 2)[..., [0, 1], :],
    }
